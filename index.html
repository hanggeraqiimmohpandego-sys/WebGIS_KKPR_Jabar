<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<title>Web GIS KKPR + RTRW (Grouped by Type + Sub by KabKota)</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<style>
  html,body{height:100%;margin:0}
  body{font-family: Arial, Helvetica, sans-serif}
  #map{height:100vh;width:100%}
  /* panel checklist kiri atas */
  .control-panel {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 1000;
    background: rgba(255,255,255,0.95);
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.25);
    padding: 8px;
    width: 300px;
    max-height: 70vh;
    overflow: auto;
  }
  .panel-title { font-weight: 700; margin-bottom: 6px; display:flex; align-items:center; justify-content:space-between; }
  .group { border-top:1px solid #eee; padding-top:6px; margin-top:6px; }
  .group .group-title { cursor:pointer; font-weight:600; display:flex; align-items:center; justify-content:space-between; }
  .sublist { margin-left:8px; margin-top:6px; }
  .small { font-size:12px; color:#666 }
  .btn { cursor:pointer; padding:4px 8px; border-radius:4px; border:1px solid #ddd; background:#f8f8f8; margin-left:6px; }
  /* legend bottom right */
  .legend { position: absolute; bottom: 10px; right: 10px; z-index:1000; background: rgba(255,255,255,0.95); padding:8px; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.2); max-height:40vh; overflow:auto; width:220px }
  .legend-title{font-weight:700;margin-bottom:6px}
  .legend-item{display:flex;align-items:center;margin-bottom:4px}
  .legend-color{width:16px;height:16px;border:1px solid #666;margin-right:8px}
  /* small control styles for home button */
  .leaflet-control-custom { background:#fff;border:2px solid rgba(0,0,0,0.15);border-radius:4px;box-shadow:0 2px 6px rgba(0,0,0,0.2); width:32px;height:32px; display:flex;align-items:center;justify-content:center; cursor:pointer }
  .leaflet-control-custom svg{width:16px;height:16px;fill:#333}
</style>
</head>
<body>

<div id="map"></div>

<!-- panel checklist -->
<div id="panel" class="control-panel" aria-hidden="false">
  <div class="panel-title">
    <div>Layer RTRW â€” Pilih Jenis & Kab/Kota</div>
    <div>
      <button id="btnExpandAll" class="btn">Expand</button>
      <button id="btnCollapseAll" class="btn">Collapse</button>
    </div>
  </div>
  <div class="small" style="margin-bottom:6px">Centang jenis untuk tampilkan semua kab/kota; klik nama kab untuk toggle sub-layer.</div>
  <div id="groupsContainer"></div>
  <hr style="margin:8px 0"/>
  <div>
    <label><input type="checkbox" id="chkShowAllTypes" checked> Tampilkan semua jenis</label>
  </div>
  <div style="margin-top:6px">
    <label><input type="checkbox" id="chkShowAllKab" checked> Tampilkan semua kab/kota (per jenis)</label>
  </div>
  <hr style="margin:8px 0"/>
  <div style="display:flex;gap:6px;flex-wrap:wrap">
    <button id="btnShowNone" class="btn">Clear</button>
    <button id="btnShowAll" class="btn">Show All</button>
  </div>
</div>

<!-- legend -->
<div id="legend" class="legend" aria-hidden="false">
  <div class="legend-title">Legenda RTRW</div>
  <div id="legendContent"></div>
</div>

<!-- JS libs -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<!-- user style mapping (you already created) -->
<script src="style/rtrw_style.js"></script>

<script>
/* ===========================
   Configuration: list ZIPs
   =========================== */

const zipList = [
  "RTRWP Kab Bandung Barat.zip","RTRWP Kab Bandung.zip","RTRWP Kab Bekasi.zip","RTRWP Kab Bogor.zip",
  "RTRWP Kab Ciamis.zip","RTRWP Kab Cianjur.zip","RTRWP Kab Cirebon.zip","RTRWP Kab Garut.zip",
  "RTRWP Kab Indramayu.zip","RTRWP Kab Karawang.zip","RTRWP Kab Kuningan.zip","RTRWP Kab Majalengka.zip",
  "RTRWP Kab Pangandaran.zip","RTRWP Kab Purwakarta.zip","RTRWP Kab Subang.zip","RTRWP Kab Sumedang.zip",
  "RTRWP Kab Tasikmalaya.zip","RTRWP Kota Bandung.zip","RTRWP Kota Banjar.zip","RTRWP Kota Bekasi.zip",
  "RTRWP Kota Bogor.zip","RTRWP Kota Cimahi.zip","RTRWP Kota Cirebon.zip","RTRWP Kota Depok.zip",
  "RTRWP Kota Sukabumi.zip","RTRWP Kota Tasikmalaya.zip"
];

// default map
const map = L.map('map').setView([-6.9, 107.6], 8);
L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  attribution: 'Tiles Â© Esri â€” Source: Esri, Maxar, Earthstar Geographics'
}).addTo(map);

/* ===========================
   Data structures to hold layers
   - typeToKabLayers: {
       "Kawasan Hutan": { "Kab Bogor": LayerGroup, "Kab Bandung": LayerGroup, ... }
     }
   - kabLayersFlat: keep mapping kabName -> { layers: [layer1, ...], bounds }
   =========================== */
const typeToKabLayers = {};
const typeToToggleState = {}; // collapsed/open for UI
const overlayControl = {}; // for potential future use

// helper random color for kab outline fallback
function randHueColor(seed){
  const h = Math.floor(Math.random() * 360);
  return `hsl(${h} 70% 45%)`.replace(/\s/g,','); // not used but left
}

/* ===========================
   LOAD KKPR first? user wanted KKPR clickable to be in front.
   We'll load RTRW first then KKPR later and ensure KKPR added last so it's on top.
   Also ensure clicking a KKPR feature brings it to front.
   =========================== */

let kkprLayer = null;
async function loadKKPR() {
  try {
    const resp = await fetch('data/kkpr.json');
    if (!resp.ok) { console.warn('KKPR not found'); return; }
    const data = await resp.json();

    kkprLayer = L.geoJSON(data, {
      style: { color: '#ff0000', weight: 2, fillOpacity: 0 },
      onEachFeature: function(f, layer){
        const p = f.properties || {};
        const nomor = p.No_KKPR || '-';
        const popup = `<b>Nomor KKPR:</b> ${nomor}<br><b>Nama:</b> ${p.Nama_Usaha||'-'}<br><a href="lampiran/${nomor}.pdf" target="_blank">ðŸ“„ Lampiran</a>`;
        layer.bindPopup(popup);
        layer.on('click', function(){
          // bring this polygon to front for visibility
          if (layer.bringToFront) layer.bringToFront();
          layer.openPopup();
        });
      }
    });
    // DON'T add to map yet â€” we'll add after RTRW is loaded to ensure KKPR on top
  } catch(e){ console.error('Fail load KKPR', e); }
}

/* ===========================
   Load all ZIPs and group by NAMOBJ
   We parse features in each zip, then for each feature get NAMOBJ and push it into
   a GeoJSON FeatureCollection per (type, kab).
   =========================== */

async function loadAllRTRW() {
  // We'll create an in-memory structure of feature arrays first: { type: { kab: [features] } }
  const temp = {}; // temp[type][kab] = [features]
  for (const zipFile of zipList) {
    const kabName = zipFile.replace('.zip',''); // full label as provided (e.g., "RTRWP Kab Bogor")
    const path = 'data/' + zipFile;
    try {
      const resp = await fetch(path);
      if (!resp.ok) { console.warn('ZIP not found:', path); continue; }
      const blob = await resp.blob();
      const zip = await JSZip.loadAsync(blob);
      const fileNames = Object.keys(zip.files).filter(f => f.toLowerCase().endsWith('.json') || f.toLowerCase().endsWith('.geojson'));
      if (fileNames.length === 0) { console.warn('no json in', zipFile); continue; }
      // if multiple files inside zip, parse each
      for (const fname of fileNames) {
        const txt = await zip.file(fname).async('string');
        const geo = JSON.parse(txt);
        const feats = (geo.features || []);
        for (const feat of feats) {
          const type = (feat.properties && feat.properties.NAMOBJ) ? feat.properties.NAMOBJ : 'UNKNOWN';
          if (!temp[type]) temp[type] = {};
          if (!temp[type][kabName]) temp[type][kabName] = { features: [], bounds:null };
          temp[type][kabName].features.push(feat);
        }
      }
    } catch(err){
      console.error('Failed reading zip', zipFile, err);
    }
  }

  // convert each temp[type][kab] into Leaflet LayerGroup (L.geoJSON)
  for (const [type, kabObj] of Object.entries(temp)) {
    typeToKabLayers[type] = {};
    typeToToggleState[type] = true; // default open
    for (const [kabName, obj] of Object.entries(kabObj)) {
      const fc = { type: 'FeatureCollection', features: obj.features };
      const layer = L.geoJSON(fc, {
        style: function(feature){
          const nama = feature.properties?.NAMOBJ;
          const fillColor = (typeof rtrwStyleByNama !== 'undefined' && rtrwStyleByNama[nama]) ? rtrwStyleByNama[nama] : '#888888';
          return { color: fillColor, weight: 1, fillOpacity: 0.35 };
        },
        onEachFeature: function(feature, layer){
          const p = feature.properties || {};
          const popup = `<b>${p.NAMOBJ || '-'}</b><br><small>${kabName}</small>`;
          layer.bindPopup(popup);
          // on click, if KKPR overlaps and user clicks KKPR layer, KKPR will bringToFront by its own handler
        }
      });
      // store and also compute bounds
      let bounds = null;
      try { bounds = layer.getBounds(); } catch(e){}
      typeToKabLayers[type][kabName] = { layer, bounds };
    }
  }

  buildPanelUI();
  // do not add all to map immediately; we'll default to showing all types/kab (config below)
  // add default shown: all
  showAllTypes();
}

/* ===========================
   PANEL UI: build groups and nested checkboxes
   =========================== */

function buildPanelUI() {
  const container = document.getElementById('groupsContainer');
  container.innerHTML = '';
  // for stable order, sort types alphabetically
  const types = Object.keys(typeToKabLayers).sort((a,b)=>a.localeCompare(b,'id'));
  for (const type of types) {
    const groupDiv = document.createElement('div');
    groupDiv.className = 'group';

    const titleDiv = document.createElement('div');
    titleDiv.className = 'group-title';
    titleDiv.innerHTML = `<span>${type}</span><span class="small" id="count-${cssSafe(type)}"></span>`;
    groupDiv.appendChild(titleDiv);

    const sublist = document.createElement('div');
    sublist.className = 'sublist';
    // build sublist of kab
    const kabs = Object.keys(typeToKabLayers[type]).sort((a,b)=>a.localeCompare(b,'id'));
    for (const kab of kabs) {
      const idChk = `chk-${cssSafe(type)}-${cssSafe(kab)}`;
      const div = document.createElement('div');
      div.innerHTML = `<label style="display:flex;align-items:center">
        <input type="checkbox" id="${idChk}" data-type="${escapeHtml(type)}" data-kab="${escapeHtml(kab)}" checked style="margin-right:6px">
        <span>${kab.replace('RTRWP ','')}</span>
      </label>`;
      sublist.appendChild(div);

      // event bind
      setTimeout(()=> { // use timeout to ensure element exists
        const chk = document.getElementById(idChk);
        chk.addEventListener('change', function(e){
          const t = this.dataset.type;
          const k = this.dataset.kab;
          if (this.checked) {
            addKabLayer(t,k);
          } else {
            removeKabLayer(t,k);
          }
        });
      },0);
    }

    // button to toggle all kabs in this type
    const btnAll = document.createElement('button');
    btnAll.className = 'btn';
    btnAll.textContent = 'Toggle Kabs';
    btnAll.onclick = () => {
      const visible = Object.values(typeToKabLayers[type]).some(x => map.hasLayer(x.layer));
      // if any visible -> hide all; else show all
      for (const kab of Object.keys(typeToKabLayers[type])) {
        const chk = document.getElementById(`chk-${cssSafe(type)}-${cssSafe(kab)}`);
        chk.checked = !visible;
        if (!visible) addKabLayer(type,kab);
        else removeKabLayer(type,kab);
      }
    };

    groupDiv.appendChild(sublist);
    groupDiv.appendChild(btnAll);
    container.appendChild(groupDiv);

    // update count
    const countSpan = document.getElementById(`count-${cssSafe(type)}`);
    if (countSpan) countSpan.textContent = ` (${Object.keys(typeToKabLayers[type]).length})`;
  }

  // global buttons
  document.getElementById('btnExpandAll').onclick = () => {
    document.querySelectorAll('.group .sublist').forEach(s=>s.style.display='block');
  };
  document.getElementById('btnCollapseAll').onclick = () => {
    document.querySelectorAll('.group .sublist').forEach(s=>s.style.display='none');
  };
  document.getElementById('btnShowAll').onclick = () => { showAllTypes(); document.querySelectorAll('#panel input[type=checkbox]').forEach(i=>i.checked=true); };
  document.getElementById('btnShowNone').onclick = () => { hideAllTypes(); document.querySelectorAll('#panel input[type=checkbox]').forEach(i=>i.checked=false); };
  document.getElementById('chkShowAllTypes').onchange = function(){ if(this.checked) showAllTypes(); else hideAllTypes(); };
  document.getElementById('chkShowAllKab').onchange = function(){ 
    document.querySelectorAll('#panel input[type=checkbox]').forEach(i=>{ i.checked = this.checked; i.dispatchEvent(new Event('change')); });
  };
}

// helpers to add/remove kab layer
function addKabLayer(type,kab) {
  const rec = typeToKabLayers[type] && typeToKabLayers[type][kab];
  if (!rec) return;
  if (!map.hasLayer(rec.layer)) {
    rec.layer.addTo(map);
  }
}
function removeKabLayer(type,kab) {
  const rec = typeToKabLayers[type] && typeToKabLayers[type][kab];
  if (!rec) return;
  if (map.hasLayer(rec.layer)) map.removeLayer(rec.layer);
}

// show/hide all types
function showAllTypes(){
  for (const type of Object.keys(typeToKabLayers)){
    for (const kab of Object.keys(typeToKabLayers[type])) {
      addKabLayer(type,kab);
      const chk = document.getElementById(`chk-${cssSafe(type)}-${cssSafe(kab)}`);
      if (chk) chk.checked = true;
    }
  }
}
function hideAllTypes(){
  for (const type of Object.keys(typeToKabLayers)){
    for (const kab of Object.keys(typeToKabLayers[type])) {
      removeKabLayer(type,kab);
      const chk = document.getElementById(`chk-${cssSafe(type)}-${cssSafe(kab)}`);
      if (chk) chk.checked = false;
    }
  }
}

/* ===========================
   After building UI, add KKPR on top and set behavior
   - KKPR should always be clickable and brought front on click
   =========================== */

async function finalizeSetup(){
  // add KKPR layer last so it is above other vector layers
  if (kkprLayer) {
    kkprLayer.addTo(map);
    // ensure kkpr interactions: when kkpr clicked bring to front (already set in loadKKPR)
  }

  // build legend from rtrwStyleByNama
  buildLegend();
}

/* ===========================
   Legend builder from rtrwStyleByNama
   =========================== */
function buildLegend(){
  const cont = document.getElementById('legendContent');
  if (!cont) return;
  cont.innerHTML = '';
  const mapKeys = Object.keys(typeof rtrwStyleByNama !== 'undefined' ? rtrwStyleByNama : {}).sort((a,b)=>a.localeCompare(b,'id'));
  for (const k of mapKeys) {
    const color = rtrwStyleByNama[k];
    const div = document.createElement('div');
    div.className = 'legend-item';
    div.innerHTML = `<div class="legend-color" style="background:${color}"></div><div>${k}</div>`;
    cont.appendChild(div);
  }
}

/* ===========================
   Utilities
   =========================== */
function cssSafe(s){ return s.replace(/\s+/g,'_').replace(/[^\w\-]/g,''); }
function escapeHtml(s){ return (s+'').replace(/"/g,'&quot;'); }

/* ===========================
   Main startup: load RTRW then KKPR then finalize
   =========================== */

(async function main(){
  await loadAllRTRW();
  await loadKKPR();
  await finalizeSetup();
})();

</script>

</body>
</html>
